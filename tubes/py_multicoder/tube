#!/usr/bin/env python

import sys
import json
import unicodedata
import re
import logging

from basetube import BaseTube

logging.basicConfig(level=logging.WARN, format="%(asctime)s %(name)s %(levelname)s %(message)s")
log = logging.getLogger(__name__)

all_chars = (unichr(i) for i in xrange(0x110000))
#control_chars = ''.join(c for c in all_chars if unicodedata.category(c) == 'Cc')
# or equivalently and much more efficiently
control_chars = ''.join(map(unichr, range(0,32) + range(127,160)))

control_char_re = re.compile('[%s]' % re.escape(control_chars))

class MulticoderTube(BaseTube):
    def handle(self, message):
        payload = message['payload']
        newPayload = self.hexEncode(payload, message)
        
        message['payload'] = self.remove_control_chars(newPayload)
        self.return_message(message)
    
    def hexEncode(self, msg, message):
        self.processing(message, "Hex", self.remove_control_chars(msg.encode('hex')))
        return self.bz2Encode(msg, message)+'Hex encoded,'
    
    def bz2Encode(self, msg, message):
        self.processing(message, "BZ2", self.remove_control_chars(msg.encode('bz2_codec')))
        return self.uuEncode(msg, message)+'BZ2 encoded,'
    
    def uuEncode(self, msg, message):
        self.processing(message, "UU", self.remove_control_chars(msg.encode('uu_codec')))
        return self.gzipEncode(msg, message)+'UU encoded,'
    
    def gzipEncode(self, msg, message):
        self.processing(message, "Zip", self.remove_control_chars(msg.encode('zlib_codec')))
        return self.punyEncode(msg, message)+'Zip encoded,'
    
    def punyEncode(self, msg, message):
        self.processing(message, "Punycode", self.remove_control_chars(msg.encode('punycode')))
        return msg+'Punycoded,'
    
    def remove_control_chars(s):
        return control_char_re.sub('', s)

def main():
    MulticoderTube("py_multicoder").run()

if __name__ == '__main__':
    main()